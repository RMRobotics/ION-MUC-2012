#pragma config(Sensor, S1,     colorLeft,      sensorCOLORFULL)
#pragma config(Sensor, S2,     colorRight,     sensorCOLORFULL)
#pragma config(Sensor, S3,     colorBack,      sensorCOLORFULL)
#pragma config(Motor,  motorB,          ,              tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          ,              tmotorNormal, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ==================================================
// ==================================================

////////////////////////////////////////////////////////////
//                                                        //
//            RICHARD MONTGOMERY ROBOTICS TEAM            //
//                                                        //
//       CODE FOR THE 2012 ION MINI URBAN CHALLENGE       //
// PRIMARY VERSION FOR WASHINGTON DC REGIONAL COMPETITION //
//                                                        //
////////////////////////////////////////////////////////////

// ==================================================
// ==================================================

// CONSTANTS

#define HIGH 30 //60 // Speed to use at white-bordered zones.
#define LOW 20 //40 // Speed to use in yellow-bordered zones, parking lots, and intersections
#define SENSITIVITY 80 // Strength of steering reactions while driving
#define DECAY 1.5 // Strength of steering's tendancy towards steering straight

#define BLACK 0
#define WHITE 1
#define RED 2
#define BLUE 3
#define YELLOW 4
#define GREEN 5

#define LEFT 0
#define RIGHT 1
#define FORWARD 2

// ==================================================
// ==================================================

// FUNCTION DECLARATIONS

void drive(int side, int destination);
void turn(int direction);
void park(int side, int space);
void unpark(int side, bool special);
int color(int side);
void move(int distance);
void pivot(int direction);
void align();

// ==================================================
// ==================================================

// MAIN PROGRAM

task main()
{
  // Turn on the color sensors and give them time to callibrate
  wait1Msec(1000);
  color(0);
  wait1Msec(1000);
  color(1);
  wait1Msec(1000);

  //Subroutine Parameters
  //  drive(side, destination)
  //  turn(direction)
  //  park(side, space)
  //  unpark(side, special)

  unpark(LEFT, true);
  turn(RIGHT);
  drive(LEFT, 0);

  wait1Msec(5000); //finish
}

// ==================================================
// ==================================================

// MAJOR SUBROUTINES

// ++++++++++++++++++++++++++++++++++++++++++++++++++

// DRIVE
// Drives along a road, stopping at a specified trigger
// Arguments:
//   side: which side of the road it will hug (0: left, 1: right)
//   destination: when to stop
//      0: to intersection treating blue the same as white
//      1: to parking lot, stops after encountering blue
//      2: to stop box, special case
//      3: to back to parking lot, stops after both sensors see white
//      4: to get to a specific lot, stops after seeing white

void drive(int side, int destination)
{
  tMotor master;
  float steering = 0;
  int adjustment = SENSITIVITY * (2 * side -1);
  int lastColor = color(side);
  //int otherColor = color((side + 1) % 2);
  int speed = LOW;

  while (true)
  {
    // @JON
    if ((destination == 0 /* stop sign */ && lastColor == RED ) ||
      (destination == 1 /* parking lot */  && lastColor == BLUE) ||
    (destination == 3 /* back of parking lot */ && (color(2) == BLUE || color(2) == RED)) ||
    (destination == 4 /* side of parking lot */ && lastColor == WHITE) ||
    (destination == 2 /* special case */ && lastColor == RED /* final parking square */ ))
    break;
    // END @JON

    steering = steering/DECAY;

    if(destination == 4)
    {
      lastColor = color((side+1) % 2);
      //otherColor = color(side);
    }
    else
    {
      lastColor = color(side);
      //otherColor = color((side + 1) % 2);
    }

    if (lastColor == BLACK || (destination == 2 && lastColor == BLUE))
    {
      steering = steering + adjustment/speed; //steer outwards
    }
    else
    {
      steering = steering - adjustment/speed; //steering inwards
      /*if (lastColor == RED || otherColor == RED)
      {
      speed = LOW/4; //go extra slow if any red has been seen
      }
      else */if (lastColor == YELLOW || (destination == 3 && lastColor == WHITE))
      {
        speed = LOW; //go slow if you see yellow or are in the parking lot
      }
      else if (lastColor == WHITE)
      {
        speed = HIGH; //go fast if you see white
      }
    }

    if (steering > 0)
    {
      master = motorC;
      nSyncedMotors = synchCB; //motor C is the master, motor B is the slave
    }
    else
    {
      master = motorB;
      nSyncedMotors = synchBC; //motor B is the master, motor C is the slave
    }

    nSyncedTurnRatio = 100 - abs(steering); //set the relative motor speeds

    motor[master] = speed; //move forwards

    wait1Msec(5);
  }
  motor[master] = 0; //stop

  nSyncedMotors = synchNone; //unsync motors

  //wait1Msec(1000);

  if (destination == 0) // if stopped at a stop sign
  {
    nxtDisplayCenteredBigTextLine(4, "STOPPED");
    wait1Msec(2000); //stay at a complete stop for two seconds
    ClearTimer(T1);
    while(color(2) != RED)
    {
      move(10);
      if(time1[T1] >= 5000)
      {
        PlayTone(220, 1);
        break;
      }
    }
  }
  else if (destination != 3) //if stopped at a parking lot, continue moving forward a certain distance.
  {
    nxtDisplayCenteredBigTextLine(5, "TO PARKING");
    for(int counter = 0; counter < 450; counter++) //For a certain distance
    {
      steering = steering/DECAY;

      if(destination == 4)
        lastColor = color((side+1)%2);
      else
        lastColor = color(side);

      if (lastColor == BLACK)
      {
        steering = steering + adjustment/LOW;
      }
      else
      {
        steering = steering - adjustment/LOW;
      }
      nxtDisplayCenteredBigTextLine(4, "%3.0f", steering);

      if (steering > 0)
      {
        master = motorC;
        nSyncedMotors = synchCB; //motor C is the master, motor B is the slave
      }
      else
      {
        master = motorB;
        nSyncedMotors = synchBC; //motor B is the master, motor C is the slave
      }

      nSyncedTurnRatio = 100 - abs(steering); //set the relative motor speeds

      motor[master] = LOW;

      wait1Msec(5);
    }
    motor[master] = 0; // stop moving

    nSyncedMotors = synchNone; // clear syncronization

    nxtDisplayCenteredBigTextLine(5, ""); //Clear line
  }
  nxtDisplayCenteredBigTextLine(4, ""); //Clear line
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++

// TURN
// Moves into an intersection, pivots as specified, and moves out of the intersection
// Arguments:
//   direction: which way to go (0: left, 1: right, 2: straight, )

void turn(int direction)
{
  //Turn
  if (direction == 0)
  {
    pivot(0);
  }
  else if (direction == 1)
  {
    pivot(1);
  }
  else
  {
    move(100);
  }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++

// PARK
// Turns and enters a parking lot, parks, and then returns to the road
// Arguments:
//   side: which side the lot is on (0: left, 1: right)
//   space: which space in the lot to park in (0: first space, 1: second space, 2: third space, etc.)

void park(int side, int space)
{
  tMotor master;

  if(space != 0)
  {
    for(int i = 0; i < space; i++)
      drive((side+1)%2, 4); //tell robot to follow Side A of road, but will actually follow the outside of Side B
  }

  nxtDisplayCenteredBigTextLine(4, "Entering Lot");

  if(side == 0)
    master = motorB;
  else
    master = motorC;
  motor[master] = LOW/2;
  wait1Msec(1000);
  ClearTimer(T1);
  while(color(side) != WHITE)
  {
    //Loop until color sensor detects white
    if(time1[T1] >= 5000)
    {
      PlayTone(220, 1);
      break;
    }
  }
  motor[master] = 0;

  drive(side, 3);
  move(30);


  nxtDisplayCenteredBigTextLine(4, "PARKED");
  wait1Msec(5000); //remain parked for five seconds
}

void unpark(int side, bool special)
{
  nxtDisplayCenteredBigTextLine(4, "Leaving Lot");
  //Unpark

  nSyncedMotors = synchBC;
  nSyncedTurnRatio = 100;
  motor[motorB] = -LOW;
  wait1Msec(500);
  ClearTimer(T1);
  while(color(2) == BLACK)
  {
    //exit the lot
    if(time1[T1] >= 5000)
    {
      PlayTone(220, 1);
      break;
    }
  }
  motor[motorB] = 0;
  nSyncedMotors = synchNone;

  nxtDisplayCenteredBigTextLine(4, ""); //Clear
  if(special == false)
  {
    turn((side+1)%2);
    drive((side+1)%2, 0);
  }
  else
  {
    turn(side);

    nSyncedMotors = synchBC;
    nSyncedTurnRatio = 100;
    motor[motorB] = -LOW;
    ClearTimer(T1);
    while(color(2) == BLACK)
      {
      //exit the lot
      if(time1[T1] >= 5000)
      {
        PlayTone(220, 1);
        break;
      }
    }
    motor[motorB] = 0;
    wait1Msec(2000);
    motor[motorB] = -LOW;
    wait1Msec(500);

    motor[motorB] = -LOW;
    ClearTimer(T1);
    while(color(0) != RED && color(1) != RED)
      {
      //exit the lot
      if(time1[T1] >= 5000)
      {
        PlayTone(220, 1);
        break;
      }
    }
    motor[motorB] = 0;
    nSyncedMotors = synchNone;
  }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++

// ==================================================
// ==================================================

// MINOR FUNCTIONS

// ++++++++++++++++++++++++++++++++++++++++++++++++++

// COLOR
// Returns the color under the sensor indicated (0: black or error, 1: white, 2: red, 3: blue, 4: yellow, 5: green)
// Arguments:
//   side which side color sensor to query (0: left, 1: right, 2: back)

int color(int side)
{
  tSensors colorSensor;
  if (side == 0)
  {
    colorSensor = colorLeft;
  }
  else if (side == 1)
  {
    colorSensor = colorRight;
  }
  else
  {
    colorSensor = colorBack;
  }

  if (!validColorSensor(colorSensor))
  {
    nxtDisplayCenteredBigTextLine(side*2, "Sensor Error");
    return 0;
  }

  int lastColor = SensorValue[colorSensor];
  wait1Msec(1);
  int currentColor = SensorValue[colorSensor];
  while (lastColor != currentColor) // For reliability, color will not move past this loop unless there are two consecutive consistent measurements at least a milisecond apart.
  {
    wait1Msec(1);
    lastColor = currentColor;
    currentColor = SensorValue[colorSensor];
  }

  switch (currentColor)
  {
  case BLACKCOLOR: nxtDisplayCenteredBigTextLine(side*2, "Black"); return BLACK;
  case REDCOLOR: nxtDisplayCenteredBigTextLine(side*2, "Red"); return RED;
  case GREENCOLOR: nxtDisplayCenteredBigTextLine(side*2, "Green"); return GREEN;
  case WHITECOLOR: nxtDisplayCenteredBigTextLine(side*2, "White"); return WHITE;
  case YELLOWCOLOR: nxtDisplayCenteredBigTextLine(side*2, "Yellow"); return YELLOW;
  case BLUECOLOR: nxtDisplayCenteredBigTextLine(side*2, "Blue"); return BLUE;
  default: nxtDisplayCenteredBigTextLine(side*2, "Bad Type"); return 0;
  }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++

// MOVE
// Drives straight forward a specified distance at LOW speed
// Arguments:
//   distance: number of degrees each wheel will spin

void move(int distance)
{


  nMotorEncoder[motorC] = 0;  //clear the motor encoders
  nMotorEncoder[motorB] = 0;

  nMotorEncoderTarget[motorC] = distance; //set the target stopping position
  nMotorEncoderTarget[motorB] = distance;

  motor[motorC] = LOW; //turn both motors on
  motor[motorB] = LOW;

  while (nMotorRunState[motorC] != runStateIdle && nMotorRunState[motorB] != runStateIdle) //while the encoder wheels are turning
  {
    // This loop waits for motors B + C to come to an idle position.
  }

  motor[motorC] = 0; //turn both motors off
  motor[motorB] = 0;

}

// ++++++++++++++++++++++++++++++++++++++++++++++++++

// PIVOT
// Spins 90 degrees about a vertical axis centered between the wheels
// Arguments:
//  direction: which direction to spin (0: left, 1: right

void pivot(int direction)
{
  tMotor master;

  if (direction == 0)
  {
    master = motorB;
  }
  else
  {
    master = motorC;
  }

  motor[master] = LOW/2; //turn both motors on
  wait1Msec(1000);

  ClearTimer(T1);
  while (color(direction) == 0)  // @JON - Consider adding auto stop if black is not seen after seconds or minutes.
  {
    // Loop until color sensor doesn't see black
    if(time1[T1] >= 5000)
    {
      PlayTone(220, 1);
      break;
    }
  }

  motor[master] = 0; //turn both motors off
  nSyncedMotors = synchNone; //unsync the motors so they are free to move independantly

  wait1Msec(1); //I don't know why this is necessary, but puting this here has caused some inexplicable errors to magically dissapear!
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++

// ALIGN
// Drives to and aligns with a line in front of it
// Arguments:
//   (None)

void align()
{
  // The following section moves back into the black, trying to better align with the edge in the process.
  if (color(0) != 0 && color(1) != 0) //if both sensors are off black
  {
    nSyncedMotors = synchBC; //motor B is the master, motor C is the slave
    motor[motorB] = -LOW/2; //move backward
    while (color(0) == 0 || color(1) == 0) //until one sensor is on black
    {
      // wait
    }
    motor[motorB] = 0; //stop moving
    nSyncedMotors = synchNone; //unsync the motors so they are free to move independantly
  }
  if (color(0) != 0) //if left is off black
  {
    motor[motorC] = -LOW/4; //begin moving the left wheel backward

    while (color(0) != 0) //while still over black
    {
      // This loop waits for the sensor to find its way to a nonblack area
    }

    motor[motorC] = 0; //stop moving
  }
  if (color(1) != 0) //if right is off black
  {
    motor[motorB] = -LOW/4; //begin moving the right wheel backward

    while (color(1) != 0) //while still over black
    {
      // This loop waits for the sensor to find its way to a nonblack area
    }

    motor[motorB] = 0; //stop moving
  }


  // The following section moves forwards from black to the first nonblack edge in front of it, trying to align in the process.
  if (color(0) == 0 && color(1) == 0) //if both sensors are on black
  {
    nSyncedMotors = synchBC; //motor B is the master, motor C is the slave
    motor[motorB] = LOW/8; //move forward
    while (color(0) == 0 && color(1) == 0) //until one sensor is off black
    {
      // wait
    }
    motor[motorB] = 0; //stop moving
    nSyncedMotors = synchNone; //unsync the motors so they are free to move independantly
  }
  if (color(0) == 0) //if left is in black
  {
    motor[motorC] = LOW/10; //begin moving the left wheel forward

    while (color(0) == 0) //while still over black
    {
      // This loop waits for the sensor to find its way to a nonblack area
    }

    motor[motorC] = 0; //stop moving
  }
  if (color(1) == 0) //if right is in black
  {
    motor[motorB] = LOW/10; //begin moving the right wheel forward

    while (color(1) == 0) //while still over black
    {
      // This loop waits for the sensor to find its way to a nonblack area
    }

    motor[motorB] = 0; //stop moving
  }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++

// ==================================================
